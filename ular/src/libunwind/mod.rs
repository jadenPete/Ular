//! # FFI bindings to LLVM's libunwind library
//!
//! This module includes auto-generated bindings from bindgen and provides safe wrappers around
//! libunwind functionality, inspired by the `libunwind-rs` crate.
//!
//! Below is a long story about why we use LLVM's libunwind library instead of using something like
//! `libunwind-rs`.
//!
//! ## Why These Bindings Exist
//!
//! An unwinding library serves a few purposes:
//! 1. Introspection about which functions are currently in the call stack
//! 2. Reading register values at various points in the call stack
//! 3. Resuming execution at a higher point in the call stack
//!
//! These generally power functionality like exception handling and debugging, but Ular just uses it
//! for garbage collection, specifically when searching for stack roots.
//!
//! We can choose between a few unwinding libraries, all of which confusingly refer to themselves as
//! "libunwind":
//! - "Mainline" libunwind (https://github.com/libunwind/libunwind)
//! - That provided by `libgcc_s`
//! - That provided by LLVM (https://github.com/llvm/llvm-project/tree/release/18.x/libunwind)
//!
//! For the most part, they provide the same symbols, but the way in which they track the addresses of
//! known functions is different, so it's best to stick to a single library. The `libunwind_rs` crate—
//! which, to my knowledge, is the only Rust unwinding library—uses mainline libunwind, whereas
//! LLVM's MCJIT compiler is confusingly linked against `libgcc_s`, not their own.
//!
//! ### Why Not `libunwind_rs`?
//!
//! Since `libunwind_rs` uses mainline libunwind under the hood, which tracks functions using a
//! different store than `libgcc_s`, we need some way of registering the
//! [`.eh_frame` section](https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html)
//! generated by LLVM. Mainline libunwind unfortunately provides no such mechanism, forcing the user
//! to register Frame Description Entries (FDEs) instead.
//!
//! ### Why Not `libgcc_s`?
//!
//! `libgcc_s` is available on most Linux systems, but the header files required to link against it
//! usually aren't. So we'd either have to download those in the build process
//! (yet another dependency) or not use bindgen, neither of which are very attractive options.

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unreachable_pub)]

use std::{ffi::c_int, mem::MaybeUninit};

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

pub struct Cursor {
    underlying: *mut unw_cursor_t,
}

impl Cursor {
    pub fn ip(&mut self) -> Result<usize, Error> {
        self.register(UNW_REG_IP)
    }

    pub fn local<A, B: FnOnce(Cursor) -> Result<A, Error>>(callback: B) -> Result<A, Error> {
        let mut context = MaybeUninit::<unw_context_t>::uninit();
        let context_pointer = context.as_mut_ptr();

        if unsafe { unw_getcontext(context_pointer) } != 0 {
            return Err(Error::Unspecified);
        }

        let mut underlying_cursor = MaybeUninit::<unw_cursor_t>::uninit();
        let underlying_cursor_pointer = underlying_cursor.as_mut_ptr();

        let code = unsafe { unw_init_local(underlying_cursor_pointer, context_pointer) };

        if code != 0 {
            return Err(Error::from_code(code));
        }

        let cursor = Cursor {
            underlying: underlying_cursor_pointer,
        };

        callback(cursor)
    }

    pub fn register(&mut self, id: i32) -> Result<usize, Error> {
        let mut result = MaybeUninit::<usize>::uninit();
        let code = unsafe { unw_get_reg(self.underlying, id, result.as_mut_ptr()) };

        if code < 0 {
            return Err(Error::from_code(code));
        }

        Ok(unsafe { result.assume_init() })
    }

    pub fn step(&mut self) -> Result<bool, Error> {
        let code = unsafe { unw_step(self.underlying) };

        if code < 0 {
            Err(Error::from_code(code))
        } else {
            Ok(code == 1)
        }
    }
}

#[derive(Debug)]
pub enum Error {
    Unspecified,
    NoMemory,
    BadRegister,
    ReadOnlyRegister,
    StopUnwind,
    InvalidInstructionPointer,
    BadFrame,
    Invalid,
    BadVersion,
    NoInfo,
}

impl Error {
    fn from_code(code: c_int) -> Self {
        match code {
            UNW_ENOMEM => Self::NoMemory,
            UNW_EBADREG => Self::BadRegister,
            UNW_EREADONLYREG => Self::ReadOnlyRegister,
            UNW_ESTOPUNWIND => Self::StopUnwind,
            UNW_EINVALIDIP => Self::InvalidInstructionPointer,
            UNW_EBADFRAME => Self::BadFrame,
            UNW_EINVAL => Self::Invalid,
            UNW_EBADVERSION => Self::BadVersion,
            UNW_ENOINFO => Self::NoInfo,
            _ => Self::Unspecified,
        }
    }
}

pub unsafe fn add_dynamic_eh_frame_section(start: usize) {
    __unw_add_dynamic_eh_frame_section(start);
}

pub unsafe fn remove_dynamic_eh_frame_section(start: usize) {
    __unw_remove_dynamic_eh_frame_section(start);
}

/// While LLVM automatically registers the `.eh_frame` sections it generates with the system's
/// unwinding library, it does so by calling `__register_frame`, which unfortunately does different
/// things with different unwinding libraries.
///
/// In `libgcc_s`, it accepts a pointer to a `.eh_frame` section. In the mainline libunwind and
/// LLVM's libunwind library, it registers an FDE, which isn't what we want.
///
/// To override this behavior, we provide our own implementation that defers to
/// `__unw_add_dynamic_eh_frame_section`, whose purpose is more well defined. We then instruct the
/// linker in [ular/build.rs](../../build.rs) to use [__wrap___register_frame] and
/// [__wrap___deregister_frame] in place of `__register_frame` and `__deregister_frame`, respectively.
///
/// See these issues for more information:
/// - [llvm-project#55681](https://github.com/llvm/llvm-project/issues/55681)
/// - [llvm-project#86](https://github.com/llvm/llvm-project/issues/86)
#[no_mangle]
pub unsafe extern "C" fn __wrap___register_frame(fde: *const u8) {
    __unw_add_dynamic_eh_frame_section(fde as unw_word_t);
}

/// Like [__wrap___register_frame], but deregisters an `.eh_frame` section.
#[no_mangle]
pub unsafe extern "C" fn __wrap___deregister_frame(fde: *const u8) {
    __unw_remove_dynamic_eh_frame_section(fde as unw_word_t);
}
