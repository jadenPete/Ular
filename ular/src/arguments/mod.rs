use clap::{Parser, ValueEnum};
use mmtk::util::options::PlanSelector;
use std::fmt::{Display, Formatter};

#[derive(Default, Parser)]
pub struct Arguments {
    /// The name of a phase whose output to print. This can be supplied multiple times.
    #[arg(long)]
    pub debug_phase: Vec<PhaseName>,

    // The garbage collection plan to use.
    #[arg(default_value_t, long)]
    #[clap(value_enum)]
    pub gc_plan: GarbageCollectionPlan,

    /// If supplied, print the stack map generated by LLVM in a human-readable format.
    #[arg(long)]
    pub print_stack_map: bool,
}

#[derive(Clone, Copy, ValueEnum)]
#[clap(rename_all = "snake_case")]
#[repr(C)]
pub enum GarbageCollectionPlan {
    GenCopy,
    GenImmix,
    Immix,
    MarkCompact,
    MarkSweep,
    NoGc,
    PageProject,
    SemiSpace,
    StickyImmix,
}

impl Default for GarbageCollectionPlan {
    fn default() -> Self {
        Self::SemiSpace
    }
}

impl From<GarbageCollectionPlan> for PlanSelector {
    fn from(plan: GarbageCollectionPlan) -> Self {
        match plan {
            GarbageCollectionPlan::GenCopy => PlanSelector::GenCopy,
            GarbageCollectionPlan::GenImmix => PlanSelector::GenImmix,
            GarbageCollectionPlan::Immix => PlanSelector::Immix,
            GarbageCollectionPlan::MarkCompact => PlanSelector::MarkCompact,
            GarbageCollectionPlan::MarkSweep => PlanSelector::MarkSweep,
            GarbageCollectionPlan::NoGc => PlanSelector::NoGC,
            GarbageCollectionPlan::PageProject => PlanSelector::PageProtect,
            GarbageCollectionPlan::SemiSpace => PlanSelector::SemiSpace,
            GarbageCollectionPlan::StickyImmix => PlanSelector::StickyImmix,
        }
    }
}

#[derive(Clone, Eq, PartialEq, ValueEnum)]
#[clap(rename_all = "snake_case")]
pub enum PhaseName {
    Lexer,
    Parser,
    Simplifier,
    Typechecker,
    Analyzer,
    JitCompiler,
    Executor,
}

impl Display for PhaseName {
    fn fmt(&self, formatter: &mut Formatter) -> std::fmt::Result {
        write!(
            formatter,
            "{}",
            match self {
                Self::Lexer => "lexer",
                Self::Parser => "parser",
                Self::Simplifier => "simplifier",
                Self::Typechecker => "typechecker",
                Self::Analyzer => "analyzer",
                Self::JitCompiler => "jit_compiler",
                Self::Executor => "executor",
            }
        )
    }
}
